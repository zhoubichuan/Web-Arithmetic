(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{191:function(t,e,_){"use strict";_.r(e);var n=_(0),s=Object(n.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"十二、树相关算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十二、树相关算法"}},[t._v("#")]),t._v(" 十二、树相关算法")]),t._v(" "),_("blockquote",[_("p",[t._v("给定一数组，判断它是否为二叉查找树的后序遍历数组")])]),t._v(" "),_("blockquote",[_("p",[t._v("思路：")])]),t._v(" "),_("p",[t._v("想想，二叉查找数树的特点，任意根结点大于左子树的所有值，而小于右子树的所有值；")]),t._v(" "),_("p",[t._v("再想想，后序遍历的特点，先遍历左子树，再遍历右子树，最后是根结点；")]),t._v(" "),_("p",[t._v("因此很容易找到根结点，然后遍历数组找出左子树（从左往右比根结点小的），剩下右边的就是右子树，然后判断右子树是否都大于根结点：")]),t._v(" "),_("p",[t._v("如果是，则递归遍历左子树，遍历右子树，如果都满足了，则是某个二叉树的后序遍历数组；")]),t._v(" "),_("p",[t._v("如果不是，则不是。")])])}],!1,null,null,null);e.default=s.exports}}]);